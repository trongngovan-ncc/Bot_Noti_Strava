const express = require('express');
const router = express.Router();
const axios = require('axios');
const sqlite3 = require('sqlite3').verbose();
const path = require('path');

// SQLite DB setup (simple, inline for demo)
const dbPath = path.join(__dirname, '../data', 'strava_bot.db');
const db = new sqlite3.Database(dbPath);

// H√†m ƒëƒÉng k√Ω webhook Strava (ch·ªâ g·ªçi 1 l·∫ßn)
async function ensureStravaWebhook(callbackUrl, verifyToken) {
  const axios = require('axios');
  try {
    // Ki·ªÉm tra ƒë√£ c√≥ subscription ch∆∞a
    const listRes = await axios.get('https://www.strava.com/api/v3/push_subscriptions', {
      params: {
        client_id: process.env.STRAVA_CLIENT_ID,
        client_secret: process.env.STRAVA_CLIENT_SECRET
      }
    });
    if (Array.isArray(listRes.data) && listRes.data.length > 0) {
      return { already: true, id: listRes.data[0].id };
    }
    // ƒêƒÉng k√Ω m·ªõi
    const res = await axios.post('https://www.strava.com/api/v3/push_subscriptions', null, {
      params: {
        client_id: process.env.STRAVA_CLIENT_ID,
        client_secret: process.env.STRAVA_CLIENT_SECRET,
        callback_url: callbackUrl,
        verify_token: verifyToken
      }
    });
    return { created: true, id: res.data.id };
  } catch (err) {
    console.error('ƒêƒÉng k√Ω webhook Strava th·∫•t b·∫°i:', err?.response?.data || err.message);
    return { error: true, message: err?.response?.data || err.message };
  }
}

// Strava OAuth callback
router.get('/callback', async (req, res) => {
  const { code, state } = req.query;
  if (!code || !state) {
    return res.status(400).send('Missing code or state');
  }
  try {
    // Exchange code for tokens
    const tokenRes = await axios.post('https://www.strava.com/oauth/token', {
      client_id: process.env.STRAVA_CLIENT_ID,
      client_secret: process.env.STRAVA_CLIENT_SECRET,
      code,
      grant_type: 'authorization_code'
    });
    const { access_token, refresh_token, expires_at, athlete } = tokenRes.data;
    // Save to DB (upsert)
    db.run(
      `INSERT OR REPLACE INTO athletes (strava_athlete_id, mezon_user_id, access_token, refresh_token, token_expires_at, athlete_name, created_at)
       VALUES (?, ?, ?, ?, ?, ?, datetime('now'))`,
      [athlete.id, state, access_token, refresh_token, new Date(expires_at * 1000).toISOString(), `${athlete.firstname} ${athlete.lastname}`],
      async (err) => {
        let webhookMsg = '';
        if (err) {
          console.error('DB error:', err);
          return res.status(500).send('L·ªói l∆∞u th√¥ng tin user v√†o DB.');
        } else {
          // ƒêƒÉng k√Ω webhook n·∫øu ch∆∞a c√≥
          const callbackUrl = `${process.env.STRAVA_WEBHOOK_URI}?token=${process.env.WEBHOOK_SECRET_TOKEN}`;
          const webhookRes = await ensureStravaWebhook(callbackUrl, process.env.WEBHOOK_SECRET_TOKEN);
          if (webhookRes.error) {
            webhookMsg = `<p>ƒêƒÉng k√Ω webhook Strava th·∫•t b·∫°i: ${JSON.stringify(webhookRes.message)}</p>`;
          } else if (webhookRes.already) {
            webhookMsg = '<p>Webhook Strava ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω tr∆∞·ªõc ƒë√≥.</p>';
          } else if (webhookRes.created) {
            webhookMsg = '<p>ƒêƒÉng k√Ω webhook Strava th√†nh c√¥ng!</p>';
          }
        }
        res.send(`
          <html>
            <head><title>Strava Connected</title></head>
            <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
              <h1>üéâ K·∫øt n·ªëi th√†nh c√¥ng!</h1>
              <p>T√†i kho·∫£n Strava c·ªßa <strong>${athlete.firstname} ${athlete.lastname}</strong> ƒë√£ ƒë∆∞·ª£c k·∫øt n·ªëi.</p>
              ${webhookMsg}
              <p>B·∫°n c√≥ th·ªÉ ƒë√≥ng trang n√†y v√† quay l·∫°i Mezon.</p>
            </body>
          </html>
        `);
      }
    );
  } catch (err) {
    console.error('Strava OAuth error:', err?.response?.data || err.message);
    res.status(500).send('K·∫øt n·ªëi Strava th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i.');
  }
});

// Webhook verification (GET) and event handler (POST)
router.get('/webhook', (req, res) => {
  // Strava sends a challenge for verification
  const challenge = req.query['hub.challenge'] || req.query['challenge'];
  if (challenge) return res.status(200).json({ "hub.challenge": challenge });
  res.status(200).send('ok');
});

router.post('/webhook', express.json({ limit: '1mb' }), async (req, res) => {
  // Quick ACK
  res.status(200).send('ok');

  // Optional: verify token in callback URL
  const token = req.query.token;
  if (token && token !== process.env.WEBHOOK_SECRET_TOKEN) {
    console.warn('Webhook token mismatch');
    return;
  }

  const event = req.body;
  // Only handle activity events
  if (event.object_type !== 'activity') return;

  const { object_id, owner_id, aspect_type } = event;
  // Find athlete in DB
  db.get('SELECT * FROM athletes WHERE strava_athlete_id = ?', [owner_id], async (err, athlete) => {
    if (err || !athlete) {
      console.warn('No athlete found for owner_id:', owner_id);
      return;
    }
    if (aspect_type === 'delete') {
      db.run('UPDATE activities SET deleted = 1 WHERE activity_id = ?', [String(object_id)]);
      return;
    }
    // Fetch activity detail from Strava
    let data;
    let accessToken = athlete.access_token;
    try {
      const r = await axios.get(`https://www.strava.com/api/v3/activities/${object_id}`,
        { headers: { Authorization: `Bearer ${accessToken}` } });
      data = r.data;
    } catch (err) {
      // N·∫øu l·ªói 401, th·ª≠ refresh token
      if (err.response && err.response.status === 401 && athlete.refresh_token) {
        try {
          const refreshRes = await axios.post('https://www.strava.com/oauth/token', {
            client_id: process.env.STRAVA_CLIENT_ID,
            client_secret: process.env.STRAVA_CLIENT_SECRET,
            grant_type: 'refresh_token',
            refresh_token: athlete.refresh_token
          });
          accessToken = refreshRes.data.access_token;
          // L∆∞u l·∫°i access_token v√† refresh_token m·ªõi v√†o DB
          db.run(`UPDATE athletes SET access_token = ?, refresh_token = ?, token_expires_at = ? WHERE strava_athlete_id = ?`,
            [refreshRes.data.access_token, refreshRes.data.refresh_token, new Date(refreshRes.data.expires_at * 1000).toISOString(), athlete.strava_athlete_id]
          );
          // Th·ª≠ l·∫°i l·∫•y activity
          const r2 = await axios.get(`https://www.strava.com/api/v3/activities/${object_id}`,
            { headers: { Authorization: `Bearer ${accessToken}` } });
          data = r2.data;
        } catch (err2) {
          console.error('Error refreshing token or fetching activity:', err2?.response?.data || err2.message);
          return;
        }
      } else {
        console.error('Error fetching activity from Strava:', err?.response?.data || err.message);
        return;
      }
    }
    // Upsert activity n·∫øu l·∫•y ƒë∆∞·ª£c data
    if (data) {
      db.run(`INSERT OR REPLACE INTO activities (activity_id, source, strava_athlete_id, sport_type, activity_name, distance_m, duration_s, start_date_local, timezone, private, deleted, created_at)
        VALUES (?, 'strava', ?, ?, ?, ?, ?, ?, ?, ?, 0, datetime('now'))`,
        [String(data.id), athlete.strava_athlete_id, data.type, data.name, data.distance, data.moving_time, data.start_date_local, data.timezone, data.private ? 1 : 0]
      );
    }
  });
});

module.exports = router;
